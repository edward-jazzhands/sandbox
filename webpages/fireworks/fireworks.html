<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Button Fireworks</title>
<style>
  html,body{height:100%;margin:0}
  body{display:grid;place-items:center;background:#0b1020;color:#fff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{position:relative;z-index:1}
  button#boom{
    font-size:1.125rem;padding:0.75rem 1.25rem;border-radius:12px;border:0;cursor:pointer;
    background:linear-gradient(180deg,#ff7 0%, #ff6 100%);color:#111;
    box-shadow:0 6px 18px rgba(0,0,0,0.4), 0 1px 0 rgba(255,255,255,0.12) inset;
    transition:transform .12s ease, filter .12s;
  }
  button#boom:active{transform:translateY(1px) scale(.995);filter:brightness(.95)}
  /* canvas sits full viewport behind the UI layer so fireworks appear "over" everything */
  canvas.fireworks{
    position:fixed;left:0;top:0;width:100vw;height:100vh;pointer-events:none;z-index:0;
    mix-blend-mode:screen; /* makes colors pop on dark backgrounds */
  }
  /* Respect reduced motion users â€” fade to a subtle pulse instead of full fireworks */
  @media (prefers-reduced-motion: reduce) {
    canvas.fireworks{display:none}
    button#boom{animation:subtle-pulse 2s infinite}
    @keyframes subtle-pulse{
      0%{transform:scale(1)}
      50%{transform:scale(1.02)}
      100%{transform:scale(1)}
    }
  }
</style>
</head>
<body>
  <canvas class="fireworks"></canvas>
  <div class="wrap">
    <button id="boom" aria-label="Launch fireworks">Launch Fireworks</button>
  </div>

<script>
(() => {
  // Basic particle fireworks on click. No external libs.
  const canvas = document.querySelector('canvas.fireworks');
  const ctx = canvas.getContext('2d', { alpha: true });
  let w = 0, h = 0, particles = [], lastTime = 0;

  function resize() {
    // Make canvas high-DPI aware
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    w = window.innerWidth; h = window.innerHeight;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = Math.round(w * dpr);
    canvas.height = Math.round(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale drawing to CSS pixels
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  // Utility: random helpers
  function rand(min, max){ return Math.random()*(max-min)+min; }
  function randInt(min, max){ return Math.floor(rand(min, max+1)); }

  // Particle model
  class Particle {
    constructor(x, y, vx, vy, hue, lifetime, size){
      this.x = x; this.y = y;
      this.vx = vx; this.vy = vy;
      this.hue = hue;
      this.lifetime = lifetime; // seconds
      this.age = 0;
      this.size = size;
      this.shimmer = Math.random()*0.9 + 0.1;
    }
    update(dt){
      // gravity + drag
      this.vy += 120 * dt; // gravity px/s^2
      this.vx *= Math.pow(0.99, dt*60); // gentle air drag
      this.vy *= Math.pow(0.99, dt*60);
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      this.age += dt;
    }
    draw(ctx){
      const t = this.age / this.lifetime;
      const alpha = Math.max(0, 1 - t);
      const size = Math.max(0.1, this.size * (1 - t*0.9));
      ctx.beginPath();
      ctx.fillStyle = `hsla(${this.hue}, 100%, ${40 + 20*(1 - t)}%, ${alpha * 0.9})`;
      ctx.moveTo(this.x, this.y);
      ctx.arc(this.x, this.y, size * this.shimmer, 0, Math.PI*2);
      ctx.fill();
    }
    get done(){ return this.age >= this.lifetime; }
  }

  function spawnFirework(x, y, options = {}) {
    const hue = options.hue ?? randInt(0, 360);
    const count = options.count ?? randInt(30, 90);
    const speed = options.speed ?? rand(120, 420);
    const spread = options.spread ?? Math.PI * rand(0.6, 2.0); // how wide the explosion is
    const lifetime = options.lifetime ?? rand(0.9, 1.8);
    const baseSize = options.size ?? rand(1.5, 3.5);

    for (let i = 0; i < count; i++){
      const angle = (Math.PI*2) * (i/count) + rand(-spread, spread) * Math.random();
      const s = speed * (0.3 + Math.random()*0.9);
      const vx = Math.cos(angle) * s;
      const vy = Math.sin(angle) * s;
      const p = new Particle(x, y, vx, vy, (hue + rand(-20,20))|0, lifetime * (0.8 + Math.random()*0.7), baseSize * (0.6 + Math.random()*1.4));
      particles.push(p);
    }
  }

  // Optional: create an ascending "shell" that explodes (nice effect)
  function launchFrom(x, y){
    const apexX = x + rand(-60, 60);
    const apexY = Math.max(50, y - rand(120, 320));
    // shell particle: it moves up then explodes at apex
    const hue = randInt(0, 360);
    const shellLifetime = rand(0.35, 0.7);
    const sx = x, sy = y;
    const vx = (apexX - sx) / shellLifetime;
    const vy = (apexY - sy) / shellLifetime;
    const shell = {
      x: sx, y: sy, vx, vy, age:0, lifetime: shellLifetime, hue
    };
    // push a special "shell" handler into particles array as a tiny object that will become an explosion
    particles.push(shell);
  }

  // Upgrade: in update loop treat shell objects specially (no draw as normal particle)
  function updateAndDraw(now){
    const t = now * 0.001;
    let dt = Math.min(0.032, t - lastTime || 0.016);
    lastTime = t;

    // translucent black to create trail effect (not full clear)
    ctx.clearRect(0,0,w,h);
    ctx.globalCompositeOperation = 'lighter'; // additive blending for glow
    // update particles; use indexed loop because we may splice
    for (let i = particles.length-1; i >= 0; i--){
      const o = particles[i];
      if (o instanceof Particle){
        o.update(dt);
        o.draw(ctx);
        if (o.done) particles.splice(i,1);
      } else {
        // a "shell" object: simple physics, explode at end of lifetime
        o.vy += 120 * dt;
        o.x += o.vx * dt;
        o.y += o.vy * dt;
        o.age += dt;
        // draw the ascending shell as a small bright dot
        const shellT = o.age / o.lifetime;
        ctx.beginPath();
        ctx.fillStyle = `hsla(${o.hue},100%,60%,${1 - shellT})`;
        ctx.arc(o.x, o.y, 2 + 2*(1 - shellT), 0, Math.PI*2);
        ctx.fill();
        if (o.age >= o.lifetime){
          // explode
          const count = randInt(40, 110);
          const speed = rand(160, 520);
          const hue = o.hue;
          for (let k=0;k<count;k++){
            const angle = Math.random() * Math.PI * 2;
            const s = speed * (0.35 + Math.random()*0.95);
            const vx = Math.cos(angle) * s + (Math.random()-0.5)*40;
            const vy = Math.sin(angle) * s + (Math.random()-0.5)*40;
            particles.push(new Particle(o.x, o.y, vx, vy, hue + rand(-30,30), rand(0.9,1.8), rand(1.5,3.5)));
          }
          particles.splice(i,1);
        }
      }
    }

    // subtle fade (draw a transparent rectangle to produce trails; comment out for crisp particles)
    ctx.globalCompositeOperation = 'destination-over';
    ctx.fillStyle = 'rgba(4,6,12,0.06)';
    ctx.fillRect(0,0,w,h);

    // keep globalCompositeOperation back
    ctx.globalCompositeOperation = 'source-over';

    requestAnimationFrame(updateAndDraw);
  }

  requestAnimationFrame(updateAndDraw);

  // Hook up the button: click position or button center
  const btn = document.getElementById('boom');
  function getBtnCenterRect(el){
    const r = el.getBoundingClientRect();
    return { x: r.left + r.width/2, y: r.top + r.height/2 };
  }

  function onPointer(e){
    // respect reduced-motion: do nothing beyond a tiny pulse
    if (matchMedia && matchMedia('(prefers-reduced-motion: reduce)').matches) return;
    const x = e.clientX ?? (getBtnCenterRect(btn).x);
    const y = e.clientY ?? (getBtnCenterRect(btn).y);
    // convert to canvas coords (canvas occupies full screen CSS pixels)
    spawnFirework(x, y, { hue: randInt(0,360) });
    // also launch an ascending shell for a layered effect
    launchFrom(x, Math.min(h - 30, y + rand(20, 80)));
  }

  btn.addEventListener('click', onPointer);
  // support touch where clientX is available
  btn.addEventListener('touchstart', (ev) => {
    ev.preventDefault();
    const t = ev.touches[0];
    const coords = t ? { clientX: t.clientX, clientY: t.clientY } : {};
    onPointer(coords);
  }, { passive: false });

  // Accessibility: keyboard activation
  btn.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      const center = getBtnCenterRect(btn);
      onPointer({ clientX: center.x, clientY: center.y });
    }
  });

  // Simple memory/perf guard: if too many particles, trim oldest
  setInterval(() => {
    const cap = 1200;
    if (particles.length > cap) particles.splice(0, particles.length - cap);
  }, 1000);

})();
</script>
</body>
</html>
